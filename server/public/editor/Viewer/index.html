<!DOCTYPE html>
<html>
	<head>
		<title>Model Viewer</title>
		<meta charset="utf-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />

		<link rel="stylesheet" href="style.css" />
		<style>
			body {
				margin: 0;
			}

			canvas {
				display: block;
			}
		</style>
	</head>

	<body>
		<select id="type-selector"></select>
		<select id="object-selector">
			<!-- Options will be added here dynamically -->
		</select>
		<button id="toggle-animation">Toggle Animation</button>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>

		<script src="generateQRCode.js"></script>
		<model-viewer
			id="model-viewer"
			ar
			autoplay
			interaction-prompt="none"
			shadow-intensity="1"
			auto-rotate
			camera-controls
			ar-modes="webxr scene-viewer quick-look"
		></model-viewer>

		<!-- <main>
			<div id="qrcode"></div>
		</main>
		<script>
			function getQueryParam(param) {
				const queryString = window.location.search;
				const urlParams = new URLSearchParams(queryString);
				return urlParams.get(param);
			}

			const idFromUrl = getQueryParam("id");
			const urlToGenerateQRCodeFor = `http://localhost:5000/generate_scene_view/${idFromUrl}`;

			var qrcode = new QRCode("qrcode", urlToGenerateQRCodeFor);
		</script> -->

		<script
			async
			src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"
		></script>

		<script type="importmap">
			{
				"imports": {
					"three": "https://unpkg.com/three@0.153.0/build/three.module.js",
					"three/addons/": "https://unpkg.com/three@0.153.0/examples/jsm/"
				}
			}
		</script>
		<!-- Import the model viewer component -->
		<script
			type="module"
			src="https://ajax.googleapis.com/ajax/libs/model-viewer/3.1.1/model-viewer.min.js"
		></script>
		<!-- Import the component -->

		<script type="module">
			import * as THREE from "three";
			import { RoomEnvironment } from "three/addons/environments/RoomEnvironment.js";
			import { OrbitControls } from "three/addons/controls/OrbitControls.js";
			import { GLTFExporter } from "three/addons/exporters/GLTFExporter.js";
			import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";

			// Create a scene
			var scene = new THREE.Scene();
			let typeselector = document.getElementById("type-selector");
			let selector = document.getElementById("object-selector");
			let sceneLoaded = false;
			let newObjectData;

			// Create a camera
			var camera = new THREE.PerspectiveCamera(
				75,
				window.innerWidth / window.innerHeight,
				0.1,
				1000
			);
			camera.position.z = 5;

			//Setting animation button to hidden
			document.getElementById("toggle-animation").style.display = "none";

			// Create a renderer
			var renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);

			const controls = new OrbitControls(camera, renderer.domElement);

			const pmremGenerator = new THREE.PMREMGenerator(renderer);
			pmremGenerator.compileEquirectangularShader();
			const defaultEnvironment = new RoomEnvironment();
			const defaultEnvironmentTexture = pmremGenerator.fromScene(
				defaultEnvironment,
				0.04
			).texture;
			scene.environment = defaultEnvironmentTexture;
			scene.background = new THREE.Color("#878787");

			// Handle window resize
			window.addEventListener("resize", function () {
				var width = window.innerWidth;
				var height = window.innerHeight;
				renderer.setSize(width, height);
				camera.aspect = width / height;
				camera.updateProjectionMatrix();
			});

			// Create a loader
			var loader = new THREE.ObjectLoader();
			var gltfLoader = new GLTFLoader();

			// Variables for storing the data
			let geometries, materials, animations, images, textures, skeletons;

			function getQueryParam(param) {
				const queryString = window.location.search;
				const urlParams = new URLSearchParams(queryString);
				return urlParams.get(param);
			}

			async function getViewProject() {
				try {
					const idFromUrl = getQueryParam("id");
					const id = "64ce36c5bee349533c36ca50";
					const response = await fetch(
						`http://localhost:5000/generate_scene_view/${idFromUrl}`
					);

					// Check if the fetch was successful
					if (!response.ok) {
						throw new Error("Network response was not ok");
					}

					const data = await response.json();

					// Collect all distinct variant values and populate the type-selector
					let distinctVariants = [
						...new Set(data.objects.map((obj) => obj.variant)),
					];
					for (let variant of distinctVariants) {
						let option = document.createElement("option");
						option.value = variant;
						option.text = variant;
						typeselector.appendChild(option);
					}

					typeselector.addEventListener("change", function () {
						// Clear the current options in the object-selector
						selector.innerHTML = "";

						// Repopulate the object-selector with names of the objects whose variant matches the selected variant
						for (let obj of data.objects) {
							if (obj.variant === typeselector.value) {
								let option = document.createElement("option");
								option.value = obj.name;
								option.text = obj.name;
								selector.appendChild(option);
							}
						}

						// Trigger a 'change' event on the object-selector to load the first object of the selected variant
						selector.dispatchEvent(new Event("change"));
					});

					// Trigger a 'change' event on the type-selector to populate the object-selector and load the first object
					typeselector.dispatchEvent(new Event("change"));

					selector.addEventListener("change", function () {
						let selectedTextures = null;
						let selectedImages = null;
						// Get the selected object
						let selectedName = selector.value;
						let selectedObject = data.objects.find(
							(obj) => obj.name === selectedName
						);
						//skeletons = loader.parseSkeletons(data.skeletons, selectedObject);
						//console.log(skeletons);
						if (data.images) {
							var imageObj = data.images.find(
								(obj) => obj.name === selectedName
							);
							if (imageObj != undefined) {
								selectedImages = imageObj.images;
								console.log(selectedImages);
								//images = loader.parseImages(selectedImages);
								images = selectedImages;
							}

							if (data.textures) {
								var textureObj = data.textures.find(
									(obj) => obj.name === selectedName
								);
								if (textureObj != undefined) {
									selectedTextures = textureObj.textures;
									console.log(selectedTextures);
									//textures = loader.parseTextures(selectedTextures, images);
								}

								let selectedMaterials = data.materials.find(
									(obj) => obj.name === selectedName
								);
								console.log(selectedMaterials);

								materials = selectedMaterials.materials;
							}
						} else {
							let selectedMaterials = data.materials.find(
								(obj) => obj.name === selectedName
							);
							console.log(selectedMaterials);
							//materials = loader.parseMaterials(selectedMaterials.materials);
							materials = selectedMaterials.materials;
						}

						console.log(animations);

						if (
							document.getElementById("type-selector").value ===
								"ModelVariant" &&
							sceneLoaded
						) {
							console.log("---Model Variant---");
							newObjectData.object = selectedObject.object;
						} else if (
							document.getElementById("type-selector").value ===
								"TextureVariant" &&
							sceneLoaded
						) {
							console.log("---Texture Variant---");
							newObjectData.materials = materials;
							newObjectData.textures = selectedTextures
								? selectedTextures
								: undefined;
							newObjectData.images = selectedImages
								? selectedImages
								: undefined;
						} else {
							newObjectData = {
								metadata: {
									version: 4.6,
									type: "Object",
									generator: "Object3D.toJSON",
								},
								geometries: data.geometries,
								materials: materials,
								textures: selectedTextures ? selectedTextures : undefined,
								images: selectedImages ? selectedImages : undefined,
								animations: data.animations,
								skeletons: data.skeletons,
								object: selectedObject.object, // the selected object's data
							};
						}

						// let newObjectData = {
						// 	metadata: {
						// 		version: 4.6,
						// 		type: "Object",
						// 		generator: "Object3D.toJSON",
						// 	},
						// 	geometries: data.geometries,
						// 	materials: materials,
						// 	textures: selectedTextures ? selectedTextures : undefined,
						// 	images: selectedImages ? selectedImages : undefined,
						// 	animations: data.animations,
						// 	skeletons: data.skeletons,
						// 	object: selectedObject.object, // the selected object's data
						// };

						function getAnimations(scene) {
							const animations = [];

							scene.traverse(function (object) {
								animations.push(...object.animations);
							});
							if (animations.length > 0) {
								document.getElementById("toggle-animation").style.display =
									"flex";
							}
							return animations;
						}

						console.log(newObjectData);
						let jsonString = JSON.stringify(newObjectData);
						let blob = new Blob([jsonString], { type: "application/json" });
						let url = URL.createObjectURL(blob);

						loader.load(url, function (obj) {
							sceneLoaded = true;
							const exporter = new GLTFExporter();
							const anim = getAnimations(obj);
							console.log(anim);
							exporter.parse(
								obj,
								function (gltf) {
									console.log(gltf);
									const output = JSON.stringify(gltf, null, 2);
									const blob = new Blob([output], { type: "text/plain" });

									const url = URL.createObjectURL(blob);
									const mv = document.querySelector("model-viewer");
									mv.src = url;
									//if the model has animations
									console.log(mv.availableAnimations);
									if (mv.availableAnimations.length > 0) {
										document.getElementById("toggle-animation").style.display =
											"flex";
									}
								},
								undefined,
								{ animations: anim }
							);
						});
					});

					// Force a 'change' event to load the first object by default
					selector.dispatchEvent(new Event("change"));

					// Start the animation
					animate();
				} catch (error) {
					// Handle the error
					console.error(
						"There has been a problem with your fetch operation:",
						error
					);
				}
			}

			getViewProject();

			let animationFlag = true;

			document
				.getElementById("toggle-animation")
				.addEventListener("click", function () {
					animationFlag = !animationFlag;
					if (animationFlag) {
						document.querySelector("model-viewer").play();
						animate();
					} else {
						document.querySelector("model-viewer").pause();
					}
				});

			// Animation function
			function animate() {
				requestAnimationFrame(animate);

				// Rotate the object for some animation
				if (animationFlag) {
					//console.log('Animating');
					// Rotate the entire scene
					scene.rotation.y += 0.005;
				}

				// Always update the OrbitControls and render the scene
				controls.update();
				//renderer.render(scene, camera);
			}
		</script>
	</body>
</html>
